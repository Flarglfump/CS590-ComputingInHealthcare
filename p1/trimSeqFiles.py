import os
import sys
import operator

if (len(sys.argv) >= 2):
    seqfiledir = sys.argv[1]
else:
    seqfiledir = input("Enter path to sequence file directory (containing sequence files initially generated by bedtools)")

if (os.path.isdir(seqfiledir)):
    outdir = os.path.join(seqfiledir, "trimmed/")
    if (not os.path.isdir(outdir)):
        os.makedirs(outdir)
else:
    print("Path \"", seqfiledir, "\" is not an existing directory. Exiting...\n", sep='')
    exit(1)

# Desired percentage threshold for determining length of sequences; e.g., 0.3 means length cutoff should retain at least 30% of samples
desiredPercentageThreshold = 0.3


for file in os.listdir(seqfiledir):
    filename = os.fsdecode(file)
    filename_noext = os.path.splitext(filename)[0]

    filepath = os.path.join(seqfiledir, filename)

    if ( "_trimmed" not in filename and os.path.isfile(filepath)):
        src = open(filepath, "r")

        outfpath = filename_noext + "_trimmed.txt"
        outfpath = os.path.join(outdir, outfpath)

        print("Opening file \"", outfpath, "\"...", sep="")
        outfile = open(outfpath, "w")

        lenDict = {}
        seqCount = 0

        # First pass - Identify count of lengths of files
        for line in src:
            if (line.startswith(">")):
                # Identifier line - skip over
                pass
            else:
                key = len(line)
                lenDict[key] = lenDict.get(key, 0) + 1
                seqCount = seqCount + 1

        lenList = []
        for key in lenDict:
            lenList.append((int(key), lenDict[key]))
        
        lenList.sort()
        
        print(filepath)
        
        print("Sequence count:", seqCount)
        # Calculate cumulative frequency
        cumulativeFreq = 0
        cutoffLen = None

        for entry in reversed(lenList):
            cumulativeFreq += entry[1]
            if cumulativeFreq / seqCount >= desiredPercentageThreshold:
                cutoffLen = entry[0]
                break

        print(f"Cutoff Length: {cutoffLen}")

        newSeqCnt = 0
        src.close()
        src = open(filepath, "r")
        for line in src:
            # Input in pairs of two lines as follows:
            # >chr1:10008-10200
            # accctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaaccctaacccaaccctaaccctaaccctaaccctaaccctaaccctaacccctaaccctaaccctaaccctaaccctaacctaaccctaaccctaaccctaa
            # Characters may be UPPERCASE or lowercase. For sake of program, convert all atgc to uppercase for trimmed file
            if (line.startswith(">")):
                # Identifier line - skip over
                pass
            elif (len(line) >= cutoffLen):
                outfile.write(line.upper())
                newSeqCnt = newSeqCnt + 1
        src.close()
        outfile.close()
        print(f"New sequence count: {newSeqCnt} ({newSeqCnt / seqCount})")

    else:
        print("File \"", filepath, "\" has already been trimmed or cannot be determined to be a regular file\n", sep='')